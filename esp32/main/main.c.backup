#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include "sdkconfig.h"
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/event_groups.h"
#include "esp_system.h"
#include "esp_log.h"
#include "nvs_flash.h"
#include "esp_bt.h"
#include "esp_gap_ble_api.h"
#include "esp_gatts_api.h"
#include "esp_bt_defs.h"
#include "esp_bt_main.h"
#include "esp_gatt_common_api.h"
#include "driver/gpio.h"
#include "esp_timer.h"

#define GATTS_TAG "TANK_MONITOR"

// GPIO Pins
#define GREY_1_3_PIN    GPIO_NUM_32
#define GREY_2_3_PIN    GPIO_NUM_33
#define GREY_FULL_PIN   GPIO_NUM_25
#define BLACK_1_3_PIN   GPIO_NUM_26
#define BLACK_2_3_PIN   GPIO_NUM_27
#define BLACK_FULL_PIN  GPIO_NUM_14
#define RESET_PIN       GPIO_NUM_4

// BLE Settings
#define DEVICE_NAME     "RV_Tank_Monitor"
#define PROFILE_NUM     1
#define PROFILE_APP_ID  0
#define SVC_INST_ID     0
#define CHAR_DECLARATION_SIZE   (sizeof(uint8_t))
#define MAX_CONNECTIONS 7

// Service UUIDs
#define TANK_SERVICE_UUID   0x00FF
#define TANK_DATA_CHAR_UUID 0xFF01
#define AUTH_CHAR_UUID      0xFF02
#define CONFIG_CHAR_UUID    0xFF03

// Stability timing (milliseconds)
#define STABILITY_CHECK_INTERVAL    5000   // Check every 5 seconds
#define STABILITY_DURATION          90000   // 90 seconds for stability
#define DEBOUNCE_DELAY_MS          100     // Debounce for sensor readings

// Tank levels
typedef enum {
    LEVEL_EMPTY = 0,
    LEVEL_1_3 = 1,
    LEVEL_2_3 = 2,
    LEVEL_FULL = 3
} tank_level_t;

// Tank data structure
typedef struct {
    tank_level_t grey_level;
    tank_level_t black_level;
    uint32_t grey_stable_start;
    uint32_t black_stable_start;
    tank_level_t grey_last_stable;
    tank_level_t black_last_stable;
    uint8_t grey_reading_stable;
    uint8_t black_reading_stable;
} tank_data_t;

// Authentication structure
typedef struct {
    char admin_pin[7];  // 6 digits + null
    char reader_pins[5][7];  // Up to 5 reader PINs
    uint8_t reader_count;
    uint8_t is_configured;
} auth_config_t;

// Client connection structure
typedef struct {
    uint16_t conn_id;
    esp_bd_addr_t remote_bda;
    uint8_t authenticated;
    uint8_t is_admin;
} client_conn_t;

// Global variables
static tank_data_t tank_data = {0};
static auth_config_t auth_config = {0};
static client_conn_t connections[MAX_CONNECTIONS] = {0};
static uint8_t conn_count = 0;
static uint16_t tank_handle_table[4];
static esp_gatt_if_t gatts_if_global = ESP_GATT_IF_NONE;
static uint8_t reset_button_start = 0;
static uint32_t reset_press_time = 0;

// BLE attributes - removed unused constants to fix compilation warnings

// Function prototypes
static void gatts_profile_event_handler(esp_gatts_cb_event_t event, 
                                       esp_gatt_if_t gatts_if, 
                                       esp_ble_gatts_cb_param_t *param);
static void init_gpio(void);
static void read_sensors_task(void *pvParameters);
static void reset_monitor_task(void *pvParameters);
static void stability_check_task(void *pvParameters);
static void save_auth_config(void);
static void load_auth_config(void);
static tank_level_t read_tank_level(int pin_1_3, int pin_2_3, int pin_full);
static void notify_all_clients(void);
static uint8_t verify_pin(const char *pin, uint8_t *is_admin);

// NVS storage functions
static void save_auth_config(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READWRITE, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGE(GATTS_TAG, "Error opening NVS handle!");
        return;
    }
    
    size_t size = sizeof(auth_config_t);
    nvs_set_blob(nvs_handle, "auth_config", &auth_config, size);
    nvs_commit(nvs_handle);
    nvs_close(nvs_handle);
}

static void load_auth_config(void) {
    nvs_handle_t nvs_handle;
    esp_err_t err = nvs_open("storage", NVS_READONLY, &nvs_handle);
    if (err != ESP_OK) {
        ESP_LOGI(GATTS_TAG, "No saved config found");
        return;
    }
    
    size_t size = sizeof(auth_config_t);
    err = nvs_get_blob(nvs_handle, "auth_config", &auth_config, &size);
    if (err != ESP_OK) {
        ESP_LOGI(GATTS_TAG, "No auth config in NVS");
    }
    nvs_close(nvs_handle);
}

static void factory_reset(void) {
    ESP_LOGI(GATTS_TAG, "Performing factory reset...");
    nvs_flash_erase();
    nvs_flash_init();
    memset(&auth_config, 0, sizeof(auth_config_t));
    esp_restart();
}

// Sensor reading with debounce
static tank_level_t read_tank_level(int pin_1_3, int pin_2_3, int pin_full) {
    // Read multiple times for debouncing
    int reads_1_3 = 0, reads_2_3 = 0, reads_full = 0;
    
    for (int i = 0; i < 5; i++) {
        reads_full += gpio_get_level(pin_full);
        reads_2_3 += gpio_get_level(pin_2_3);
        reads_1_3 += gpio_get_level(pin_1_3);
        vTaskDelay(pdMS_TO_TICKS(20));
    }
    
    // Majority vote (3 out of 5)
    if (reads_full >= 3) return LEVEL_FULL;
    if (reads_2_3 >= 3) return LEVEL_2_3;
    if (reads_1_3 >= 3) return LEVEL_1_3;
    return LEVEL_EMPTY;
}

// Initialize GPIO pins
static void init_gpio(void) {
    // Configure sensor input pins with pull-down
    gpio_config_t io_conf = {
        .intr_type = GPIO_INTR_DISABLE,
        .mode = GPIO_MODE_INPUT,
        .pin_bit_mask = (1ULL << GREY_1_3_PIN) | (1ULL << GREY_2_3_PIN) | 
                       (1ULL << GREY_FULL_PIN) | (1ULL << BLACK_1_3_PIN) | 
                       (1ULL << BLACK_2_3_PIN) | (1ULL << BLACK_FULL_PIN),
        .pull_down_en = GPIO_PULLDOWN_ENABLE,
        .pull_up_en = GPIO_PULLUP_DISABLE
    };
    gpio_config(&io_conf);
    
    // Configure reset pin with pull-down
    io_conf.pin_bit_mask = (1ULL << RESET_PIN);
    gpio_config(&io_conf);
}

// Sensor reading task
static void read_sensors_task(void *pvParameters) {
    while (1) {
        tank_level_t grey = read_tank_level(GREY_1_3_PIN, GREY_2_3_PIN, GREY_FULL_PIN);
        tank_level_t black = read_tank_level(BLACK_1_3_PIN, BLACK_2_3_PIN, BLACK_FULL_PIN);
        
        // Update tank data
        tank_data.grey_level = grey;
        tank_data.black_level = black;
        
        // Log current levels
        ESP_LOGI(GATTS_TAG, "Grey: %d, Black: %d", grey, black);
        
        vTaskDelay(pdMS_TO_TICKS(STABILITY_CHECK_INTERVAL));
    }
}

// Stability checking task
static void stability_check_task(void *pvParameters) {
    while (1) {
        uint32_t now = esp_timer_get_time() / 1000;  // Convert to ms
        
        // Check grey tank stability
        if (tank_data.grey_level != tank_data.grey_last_stable) {
            tank_data.grey_stable_start = now;
            tank_data.grey_last_stable = tank_data.grey_level;
            tank_data.grey_reading_stable = 0;
        } else if ((now - tank_data.grey_stable_start) >= STABILITY_DURATION) {
            if (!tank_data.grey_reading_stable) {
                tank_data.grey_reading_stable = 1;
                notify_all_clients();
                ESP_LOGI(GATTS_TAG, "Grey tank stable at level %d", tank_data.grey_level);
            }
        }
        
        // Check black tank stability
        if (tank_data.black_level != tank_data.black_last_stable) {
            tank_data.black_stable_start = now;
            tank_data.black_last_stable = tank_data.black_level;
            tank_data.black_reading_stable = 0;
        } else if ((now - tank_data.black_stable_start) >= STABILITY_DURATION) {
            if (!tank_data.black_reading_stable) {
                tank_data.black_reading_stable = 1;
                notify_all_clients();
                ESP_LOGI(GATTS_TAG, "Black tank stable at level %d", tank_data.black_level);
            }
        }
        
        vTaskDelay(pdMS_TO_TICKS(5000));
    }
}

// Reset button monitor task
static void reset_monitor_task(void *pvParameters) {
    while (1) {
        int reset_state = gpio_get_level(RESET_PIN);
        
        if (reset_state && !reset_button_start) {
            reset_button_start = 1;
            reset_press_time = esp_timer_get_time() / 1000;
        } else if (!reset_state && reset_button_start) {
            reset_button_start = 0;
        } else if (reset_button_start) {
            uint32_t press_duration = (esp_timer_get_time() / 1000) - reset_press_time;
            if (press_duration >= 10000) {  // 10 seconds
                factory_reset();
            }
        }
        
        vTaskDelay(pdMS_TO_TICKS(100));
    }
}

// Verify PIN
static uint8_t verify_pin(const char *pin, uint8_t *is_admin) {
    if (!auth_config.is_configured) {
        return 1;  // No auth configured yet
    }
    
    if (strcmp(pin, auth_config.admin_pin) == 0) {
        *is_admin = 1;
        return 1;
    }
    
    for (int i = 0; i < auth_config.reader_count; i++) {
        if (strcmp(pin, auth_config.reader_pins[i]) == 0) {
            *is_admin = 0;
            return 1;
        }
    }
    
    return 0;
}

// Notify all connected clients
static void notify_all_clients(void) {
    if (gatts_if_global == ESP_GATT_IF_NONE) return;
    
    uint8_t notify_data[6];
    notify_data[0] = tank_data.grey_level;
    notify_data[1] = tank_data.grey_reading_stable;
    notify_data[2] = tank_data.black_level;
    notify_data[3] = tank_data.black_reading_stable;
    notify_data[4] = (tank_data.grey_level == LEVEL_FULL || tank_data.grey_level == LEVEL_2_3) ? 1 : 0;
    notify_data[5] = (tank_data.black_level == LEVEL_FULL || tank_data.black_level == LEVEL_2_3) ? 1 : 0;
    
    for (int i = 0; i < conn_count; i++) {
        if (connections[i].authenticated) {
            esp_ble_gatts_send_indicate(gatts_if_global, connections[i].conn_id,
                                       tank_handle_table[1], sizeof(notify_data),
                                       notify_data, false);
        }
    }
}

// GATT server profile
struct gatts_profile_inst {
    esp_gatts_cb_t gatts_cb;
    uint16_t gatts_if;
    uint16_t app_id;
    uint16_t conn_id;
    uint16_t service_handle;
    esp_gatt_srvc_id_t service_id;
    uint16_t char_handle;
    esp_bt_uuid_t char_uuid;
    esp_gatt_perm_t perm;
    esp_gatt_char_prop_t property;
    uint16_t descr_handle;
    esp_bt_uuid_t descr_uuid;
};

static struct gatts_profile_inst profile_tab[PROFILE_NUM] = {
    [PROFILE_APP_ID] = {
        .gatts_cb = gatts_profile_event_handler,
        .gatts_if = ESP_GATT_IF_NONE,
    },
};

// BLE GAP event handler
static void gap_event_handler(esp_gap_ble_cb_event_t event, esp_ble_gap_cb_param_t *param) {
    switch (event) {
    case ESP_GAP_BLE_ADV_DATA_SET_COMPLETE_EVT:
        esp_ble_gap_start_advertising(&(esp_ble_adv_params_t){
            .adv_int_min = 0x20,
            .adv_int_max = 0x40,
            .adv_type = ADV_TYPE_IND,
            .own_addr_type = BLE_ADDR_TYPE_PUBLIC,
            .channel_map = ADV_CHNL_ALL,
            .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY,
        });
        break;
    case ESP_GAP_BLE_ADV_START_COMPLETE_EVT:
        if (param->adv_start_cmpl.status != ESP_BT_STATUS_SUCCESS) {
            ESP_LOGE(GATTS_TAG, "Advertising start failed");
        }
        break;
    default:
        break;
    }
}

// GATTS profile event handler
static void gatts_profile_event_handler(esp_gatts_cb_event_t event, 
                                       esp_gatt_if_t gatts_if,
                                       esp_ble_gatts_cb_param_t *param) {
    switch (event) {
    case ESP_GATTS_REG_EVT:
        ESP_LOGI(GATTS_TAG, "REGISTER_APP_EVT, status %d, app_id %d",
                param->reg.status, param->reg.app_id);
        
        gatts_if_global = gatts_if;
        
        // Set device name
        esp_ble_gap_set_device_name(DEVICE_NAME);
        
        // Configure advertising data
        esp_ble_adv_data_t adv_data = {
            .set_scan_rsp = false,
            .include_name = true,
            .include_txpower = false,
            .min_interval = 0x0006,
            .max_interval = 0x0010,
            .appearance = 0x00,
            .manufacturer_len = 0,
            .p_manufacturer_data = NULL,
            .service_data_len = 0,
            .p_service_data = NULL,
            .service_uuid_len = 0,
            .p_service_uuid = NULL,
            .flag = (ESP_BLE_ADV_FLAG_GEN_DISC | ESP_BLE_ADV_FLAG_BREDR_NOT_SPT),
        };
        esp_ble_gap_config_adv_data(&adv_data);
        
        // Create service
        esp_ble_gatts_create_service(gatts_if, &(esp_gatt_srvc_id_t){
            .is_primary = true,
            .id = {
                .inst_id = 0x00,
                .uuid = {
                    .len = ESP_UUID_LEN_16,
                    .uuid = {.uuid16 = TANK_SERVICE_UUID},
                },
            },
        }, 10);
        break;
        
    case ESP_GATTS_CREATE_EVT:
        ESP_LOGI(GATTS_TAG, "CREATE_SERVICE_EVT, status %d, service_handle %d",
                param->create.status, param->create.service_handle);
        
        profile_tab[PROFILE_APP_ID].service_handle = param->create.service_handle;
        
        // Add characteristics
        esp_ble_gatts_start_service(param->create.service_handle);
        
        // Tank data characteristic
        esp_ble_gatts_add_char(param->create.service_handle,
                              &(esp_bt_uuid_t){
                                  .len = ESP_UUID_LEN_16,
                                  .uuid = {.uuid16 = TANK_DATA_CHAR_UUID},
                              },
                              ESP_GATT_PERM_READ,
                              ESP_GATT_CHAR_PROP_BIT_READ | ESP_GATT_CHAR_PROP_BIT_NOTIFY,
                              NULL, NULL);
        break;
        
    case ESP_GATTS_ADD_CHAR_EVT:
        ESP_LOGI(GATTS_TAG, "ADD_CHAR_EVT, status %d, attr_handle %d",
                param->add_char.status, param->add_char.attr_handle);
        
        if (param->add_char.char_uuid.uuid.uuid16 == TANK_DATA_CHAR_UUID) {
            tank_handle_table[1] = param->add_char.attr_handle;
            
            // Add auth characteristic
            esp_ble_gatts_add_char(profile_tab[PROFILE_APP_ID].service_handle,
                                  &(esp_bt_uuid_t){
                                      .len = ESP_UUID_LEN_16,
                                      .uuid = {.uuid16 = AUTH_CHAR_UUID},
                                  },
                                  ESP_GATT_PERM_WRITE,
                                  ESP_GATT_CHAR_PROP_BIT_WRITE,
                                  NULL, NULL);
        } else if (param->add_char.char_uuid.uuid.uuid16 == AUTH_CHAR_UUID) {
            tank_handle_table[2] = param->add_char.attr_handle;
            
            // Add config characteristic
            esp_ble_gatts_add_char(profile_tab[PROFILE_APP_ID].service_handle,
                                  &(esp_bt_uuid_t){
                                      .len = ESP_UUID_LEN_16,
                                      .uuid = {.uuid16 = CONFIG_CHAR_UUID},
                                  },
                                  ESP_GATT_PERM_READ | ESP_GATT_PERM_WRITE,
                                  ESP_GATT_CHAR_PROP_BIT_READ | ESP_GATT_CHAR_PROP_BIT_WRITE,
                                  NULL, NULL);
        } else if (param->add_char.char_uuid.uuid.uuid16 == CONFIG_CHAR_UUID) {
            tank_handle_table[3] = param->add_char.attr_handle;
        }
        break;
        
    case ESP_GATTS_CONNECT_EVT:
        ESP_LOGI(GATTS_TAG, "ESP_GATTS_CONNECT_EVT, conn_id %d", param->connect.conn_id);
        
        if (conn_count < MAX_CONNECTIONS) {
            connections[conn_count].conn_id = param->connect.conn_id;
            memcpy(connections[conn_count].remote_bda, param->connect.remote_bda, 6);
            connections[conn_count].authenticated = !auth_config.is_configured;  // Auto-auth if not configured
            conn_count++;
        }
        
        esp_ble_conn_update_params_t conn_params = {0};
        memcpy(conn_params.bda, param->connect.remote_bda, sizeof(esp_bd_addr_t));
        conn_params.latency = 0;
        conn_params.max_int = 0x20;
        conn_params.min_int = 0x10;
        conn_params.timeout = 400;
        esp_ble_gap_update_conn_params(&conn_params);
        break;
        
    case ESP_GATTS_DISCONNECT_EVT:
        ESP_LOGI(GATTS_TAG, "ESP_GATTS_DISCONNECT_EVT");
        
        // Remove from connections
        for (int i = 0; i < conn_count; i++) {
            if (connections[i].conn_id == param->disconnect.conn_id) {
                for (int j = i; j < conn_count - 1; j++) {
                    connections[j] = connections[j + 1];
                }
                conn_count--;
                break;
            }
        }
        
        // Restart advertising
        esp_ble_gap_start_advertising(&(esp_ble_adv_params_t){
            .adv_int_min = 0x20,
            .adv_int_max = 0x40,
            .adv_type = ADV_TYPE_IND,
            .own_addr_type = BLE_ADDR_TYPE_PUBLIC,
            .channel_map = ADV_CHNL_ALL,
            .adv_filter_policy = ADV_FILTER_ALLOW_SCAN_ANY_CON_ANY,
        });
        break;
        
    case ESP_GATTS_READ_EVT:
        ESP_LOGI(GATTS_TAG, "GATT_READ_EVT, handle %d", param->read.handle);
        
        // Find connection
        client_conn_t *client = NULL;
        for (int i = 0; i < conn_count; i++) {
            if (connections[i].conn_id == param->read.conn_id) {
                client = &connections[i];
                break;
            }
        }
        
        if (param->read.handle == tank_handle_table[1]) {
            // Tank data - only if authenticated
            if (client && client->authenticated) {
                uint8_t data[6];
                data[0] = tank_data.grey_level;
                data[1] = tank_data.grey_reading_stable;
                data[2] = tank_data.black_level;
                data[3] = tank_data.black_reading_stable;
                data[4] = 0;
                data[5] = 0;
                
                esp_gatt_rsp_t rsp;
                memset(&rsp, 0, sizeof(esp_gatt_rsp_t));
                rsp.attr_value.handle = param->read.handle;
                rsp.attr_value.len = sizeof(data);
                memcpy(rsp.attr_value.value, data, sizeof(data));
                esp_ble_gatts_send_response(gatts_if, param->read.conn_id,
                                           param->read.trans_id, ESP_GATT_OK, &rsp);
            } else {
                esp_ble_gatts_send_response(gatts_if, param->read.conn_id,
                                           param->read.trans_id, ESP_GATT_AUTH_FAIL, NULL);
            }
        }
        break;
        
    case ESP_GATTS_WRITE_EVT:
        ESP_LOGI(GATTS_TAG, "GATT_WRITE_EVT, handle %d, value len %d",
                param->write.handle, param->write.len);
        
        // Find connection
        client = NULL;
        for (int i = 0; i < conn_count; i++) {
            if (connections[i].conn_id == param->write.conn_id) {
                client = &connections[i];
                break;
            }
        }
        
        if (param->write.handle == tank_handle_table[2]) {
            // Auth characteristic
            if (param->write.len >= 6) {
                char pin[7] = {0};
                memcpy(pin, param->write.value, 6);
                uint8_t is_admin = 0;
                
                if (verify_pin(pin, &is_admin)) {
                    client->authenticated = 1;
                    client->is_admin = is_admin;
                    ESP_LOGI(GATTS_TAG, "Client authenticated as %s", is_admin ? "admin" : "reader");
                } else {
                    ESP_LOGI(GATTS_TAG, "Authentication failed");
                }
            }
        } else if (param->write.handle == tank_handle_table[3]) {
            // Config characteristic - admin only
            if (client && client->authenticated && client->is_admin) {
                // Parse config command
                if (param->write.len > 0) {
                    char cmd = param->write.value[0];
                    if (cmd == 'A' && param->write.len == 7) {  // Set admin PIN
                        memcpy(auth_config.admin_pin, param->write.value + 1, 6);
                        auth_config.is_configured = 1;
                        save_auth_config();
                        ESP_LOGI(GATTS_TAG, "Admin PIN set");
                    } else if (cmd == 'R' && param->write.len == 7) {  // Add reader PIN
                        if (auth_config.reader_count < 5) {
                            memcpy(auth_config.reader_pins[auth_config.reader_count],
                                  param->write.value + 1, 6);
                            auth_config.reader_count++;
                            save_auth_config();
                            ESP_LOGI(GATTS_TAG, "Reader PIN added");
                        }
                    }
                }
            }
        }
        
        if (param->write.need_rsp) {
            esp_ble_gatts_send_response(gatts_if, param->write.conn_id,
                                       param->write.trans_id, ESP_GATT_OK, NULL);
        }
        break;
        
    default:
        break;
    }
}

// GATTS event handler
static void gatts_event_handler(esp_gatts_cb_event_t event, esp_gatt_if_t gatts_if,
                               esp_ble_gatts_cb_param_t *param) {
    if (event == ESP_GATTS_REG_EVT) {
        if (param->reg.status == ESP_GATT_OK) {
            profile_tab[param->reg.app_id].gatts_if = gatts_if;
        } else {
            ESP_LOGI(GATTS_TAG, "Reg app failed, app_id %04x, status %d",
                    param->reg.app_id, param->reg.status);
            return;
        }
    }
    
    for (int idx = 0; idx < PROFILE_NUM; idx++) {
        if (gatts_if == ESP_GATT_IF_NONE || 
            gatts_if == profile_tab[idx].gatts_if) {
            if (profile_tab[idx].gatts_cb) {
                profile_tab[idx].gatts_cb(event, gatts_if, param);
            }
        }
    }
}

void app_main(void) {
    esp_err_t ret;
    
    // Initialize NVS
    ret = nvs_flash_init();
    if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
        ESP_ERROR_CHECK(nvs_flash_erase());
        ret = nvs_flash_init();
    }
    ESP_ERROR_CHECK(ret);
    
    // Load saved configuration
    load_auth_config();
    
    // Initialize GPIO
    init_gpio();
    
    // Initialize Bluetooth
    ESP_ERROR_CHECK(esp_bt_controller_mem_release(ESP_BT_MODE_CLASSIC_BT));
    
    esp_bt_controller_config_t bt_cfg = BT_CONTROLLER_INIT_CONFIG_DEFAULT();
    ret = esp_bt_controller_init(&bt_cfg);
    if (ret) {
        ESP_LOGE(GATTS_TAG, "%s initialize controller failed: %s", __func__, esp_err_to_name(ret));
        return;
    }
    
    ret = esp_bt_controller_enable(ESP_BT_MODE_BLE);
    if (ret) {
        ESP_LOGE(GATTS_TAG, "%s enable controller failed: %s", __func__, esp_err_to_name(ret));
        return;
    }
    
    ret = esp_bluedroid_init();
    if (ret) {
        ESP_LOGE(GATTS_TAG, "%s init bluetooth failed: %s", __func__, esp_err_to_name(ret));
        return;
    }
    
    ret = esp_bluedroid_enable();
    if (ret) {
        ESP_LOGE(GATTS_TAG, "%s enable bluetooth failed: %s", __func__, esp_err_to_name(ret));
        return;
    }
    
    ret = esp_ble_gatts_register_callback(gatts_event_handler);
    if (ret) {
        ESP_LOGE(GATTS_TAG, "gatts register error, error code = %x", ret);
        return;
    }
    
    ret = esp_ble_gap_register_callback(gap_event_handler);
    if (ret) {
        ESP_LOGE(GATTS_TAG, "gap register error, error code = %x", ret);
        return;
    }
    
    ret = esp_ble_gatts_app_register(PROFILE_APP_ID);
    if (ret) {
        ESP_LOGE(GATTS_TAG, "gatts app register error, error code = %x", ret);
        return;
    }
    
    esp_err_t local_mtu_ret = esp_ble_gatt_set_local_mtu(500);
    if (local_mtu_ret) {
        ESP_LOGE(GATTS_TAG, "set local MTU failed, error code = %x", local_mtu_ret);
    }
    
    // Create tasks
    xTaskCreate(read_sensors_task, "read_sensors", 4096, NULL, 5, NULL);
    xTaskCreate(stability_check_task, "stability_check", 4096, NULL, 5, NULL);
    xTaskCreate(reset_monitor_task, "reset_monitor", 2048, NULL, 5, NULL);
    
    ESP_LOGI(GATTS_TAG, "RV Tank Monitor started");
}